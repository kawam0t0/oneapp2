module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/process [external] (process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/timers [external] (timers, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("timers", () => require("timers"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/string_decoder [external] (string_decoder, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[project]/oneapp/app/api/dashboard/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GET",
    ()=>GET
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$oneapp$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/oneapp/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$oneapp$2f$node_modules$2f$mysql2$2f$promise$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/oneapp/node_modules/mysql2/promise.js [app-route] (ecmascript)");
;
;
const getConnection = async ()=>{
    return await __TURBOPACK__imported__module__$5b$project$5d2f$oneapp$2f$node_modules$2f$mysql2$2f$promise$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].createConnection({
        host: process.env.DB_HOST || "34.67.209.187",
        port: Number.parseInt(process.env.DB_PORT || "3306"),
        user: process.env.DB_USER || "your_username",
        password: process.env.DB_PASSWORD || "your_password",
        database: process.env.DB_NAME || "your_database_name",
        ssl: {
            rejectUnauthorized: false
        }
    });
};
const categorizeItem = (details)=>{
    if (!details) return "その他";
    if (details.includes("高崎棟高店バキューム")) return null;
    if (details.includes("サブスク")) return "サブスク";
    if (details.includes("リピ")) return "リピート";
    if (details.includes("新規")) return "新規";
    if (details.includes("⇒")) return "コースアップ";
    if (details.includes("ポイント")) return "ポイント";
    if (details.includes("キャンペーン")) return "キャンペーン";
    if (details.includes("無料券")) return "無料券";
    return details;
};
const categorizeCourse = (details)=>{
    if (!details) return null;
    if (details.includes("プレミアム")) return "プレミアム";
    if (details.includes("プラス")) return "プラス";
    if (details.includes("ナイアガラ")) return "ナイアガラ";
    if (details.includes("セラミック")) return "セラミック";
    return null;
};
const aggregateData = (rows)=>{
    const storeMap = new Map();
    rows.forEach((row)=>{
        const store = row.store;
        const item = categorizeItem(row.details);
        const count = row.count;
        if (!store || store === "0" || store.toString().trim() === "") {
            return;
        }
        if (item === null) {
            return;
        }
        if (!storeMap.has(store)) {
            storeMap.set(store, {
                items: {},
                total: 0
            });
        }
        const storeData = storeMap.get(store);
        storeData.items[item] = (storeData.items[item] || 0) + count;
        storeData.total += count;
    });
    return Array.from(storeMap.entries()).map(([store, data])=>({
            store,
            items: data.items,
            total: data.total
        }));
};
const STORE_ORDER = [
    "SPLASH'N'GO!前橋50号店",
    "SPLASH'N'GO!伊勢崎韮塚店",
    "SPLASH'N'GO!高崎棟高店",
    "SPLASH'N'GO!足利緑町店",
    "SPLASH'N'GO!新前橋店",
    "SPLASH'N'GO!太田新田店"
];
async function GET(request) {
    try {
        const { searchParams } = new URL(request.url);
        const period = searchParams.get("period") || "2025-11";
        const categoriesOnly = searchParams.get("categories") === "true";
        const [year, month] = period.split("-");
        const startDate = `${year}-${month}-01`;
        const endDate = new Date(Number.parseInt(year), Number.parseInt(month), 0).getDate();
        const endDateStr = `${year}-${month}-${endDate}`;
        const today = new Date();
        const todayStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, "0")}-${String(today.getDate()).padStart(2, "0")}`;
        const connection = await getConnection();
        if (categoriesOnly) {
            console.log("[v0] Categories only request for period:", startDate, "to", endDateStr);
            const [categoryRows] = await connection.execute(`SELECT store, details, COUNT(*) as count 
         FROM invoice 
         WHERE Date >= ? AND Date <= ?
         GROUP BY store, details`, [
                startDate,
                endDateStr
            ]);
            console.log("[v0] Raw category rows count:", categoryRows.length);
            console.log("[v0] Sample rows:", categoryRows.slice(0, 5));
            await connection.end();
            const storeMap = new Map();
            categoryRows.forEach((row)=>{
                const store = row.store;
                const course = categorizeCourse(row.details);
                const count = Number(row.count);
                if (!store || store === "0" || store.toString().trim() === "" || !course) {
                    return;
                }
                if (!storeMap.has(store)) {
                    storeMap.set(store, {
                        courses: new Map(),
                        total: 0
                    });
                }
                const storeData = storeMap.get(store);
                storeData.courses.set(course, (storeData.courses.get(course) || 0) + count);
                storeData.total += count;
            });
            console.log("[v0] Processed stores:", Array.from(storeMap.keys()));
            // 店舗順にソートして結果を作成
            const storeCategories = STORE_ORDER.filter((store)=>storeMap.has(store)).map((store)=>{
                const data = storeMap.get(store);
                const categories = Array.from(data.courses.entries()).map(([name, value])=>({
                        name,
                        value,
                        percentage: data.total > 0 ? (value / data.total * 100).toFixed(1) : "0"
                    })).sort((a, b)=>b.value - a.value);
                return {
                    store,
                    categories,
                    total: data.total
                };
            });
            console.log("[v0] Final storeCategories:", storeCategories);
            return __TURBOPACK__imported__module__$5b$project$5d2f$oneapp$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                storeCategories
            });
        }
        // 通常のリクエスト処理
        const [monthlyRows] = await connection.execute(`SELECT store, details, COUNT(*) as count 
       FROM onetime 
       WHERE date >= ? AND date <= ?
       AND (card_entry_method IS NULL OR card_entry_method != 'KEYED')
       GROUP BY store, details
       ORDER BY store, details`, [
            startDate,
            endDateStr
        ]);
        const [todayRows] = await connection.execute(`SELECT store, details, COUNT(*) as count 
       FROM onetime 
       WHERE date = ?
       AND (card_entry_method IS NULL OR card_entry_method != 'KEYED')
       GROUP BY store, details
       ORDER BY store, details`, [
            todayStr
        ]);
        const [invoiceRows] = await connection.execute(`SELECT 
         DATE_FORMAT(Date, '%Y-%m') as month,
         store,
         COUNT(*) as count
       FROM invoice
       WHERE Date >= DATE_SUB(?, INTERVAL 11 MONTH)
         AND Date <= LAST_DAY(?)
       GROUP BY DATE_FORMAT(Date, '%Y-%m'), store
       ORDER BY month ASC, store`, [
            startDate,
            endDateStr
        ]);
        await connection.end();
        const monthlyData = aggregateData(monthlyRows);
        const todayData = aggregateData(todayRows);
        const invoiceDataMap = new Map();
        invoiceRows.forEach((row)=>{
            const month = row.month;
            const store = row.store;
            const count = Number(row.count);
            if (!store || store === "0" || store.toString().trim() === "") {
                return;
            }
            if (!invoiceDataMap.has(month)) {
                invoiceDataMap.set(month, {});
            }
            invoiceDataMap.get(month)[store] = count;
        });
        const invoiceMonthly = Array.from(invoiceDataMap.entries()).sort((a, b)=>a[0].localeCompare(b[0])).map(([month, stores])=>({
                month,
                ...stores
            }));
        return __TURBOPACK__imported__module__$5b$project$5d2f$oneapp$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            monthly: monthlyData,
            today: todayData,
            invoiceMonthly
        });
    } catch (error) {
        console.error("[v0] Database error:", error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$oneapp$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: "データベース接続エラー",
            details: String(error)
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__e36593b5._.js.map